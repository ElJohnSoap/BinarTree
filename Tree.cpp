#include "Tree.h"
Tree::Tree()
{
	root = NULL;
}
Tree::~Tree()
{
	Del();
}

//Рекурсивный обход дерева
void Tree::Print(TreeElem* Node)
{
	if (Node != 0)
	{
		Print(Node->left);
		cout << Node->keyNumb
			<< endl;
		Print(Node->right);
	}
}
//TreeElem* Tree::Search(TreeElem* Node, char* k)
//{
//	//Пока есть узлы и ключи не совпадают
//	while (Node != 0 && strcmp(k, Node->keyNumb) != 0)
//	{
//		if (strcmp(k, Node->keyNumb) < 0)
//			Node = Node->left;
//		else
//			Node = Node->right;
//	}
//	return Node;
//}
TreeElem* Tree::Min(TreeElem* Node)
{
	//Поиск самого "левого" узла
	if (Node != 0)
		while (Node->left != 0)
			Node = Node->left;
	return Node;
}
//TreeElem* Tree::Max(TreeElem* Node)
//{
//		//Поиск самого "правого" узла
//		if (Node != 0)
//			while (Node->right != 0)
//				Node = Node->right;
//	return Node;
//}
TreeElem* Tree::Next(TreeElem* Node)
{
	TreeElem* y = 0;
	if (Node != 0)
	{
		//если есть правый потомок
		if (Node->right != 0)
			return Min(Node->right);
		//родитель узла
		y = Node->parent;
		//если Node не корень и Node справа
		while (y != 0 && Node == y->right)
		{
			//Движемся вверх
			Node = y;
			y = y->parent;
		}
	}
	return y;
}
//TreeElem* Tree::Previous(TreeElem* Node)
//{
//	TreeElem* y = 0;
//	if (Node != 0)
//	{
//		//если есть левый потомок
//		if (Node->left != 0)
//			return Max(Node->left);
//
//			//родитель узла
//			y = Node->parent;
//		//если Node не корень и Node слева
//		while (y != 0 && Node == y->left)
//		{
//			//Движемся вверх
//			Node = y;
//			y = y->parent;
//		}
//	}
//	return y;
//}
TreeElem* Tree::GetRoot()
{
	return root;
}
void Tree::Insert(TreeElem* z)
{
	//потомков нет
	z->left = NULL;
	z->right = NULL;
	TreeElem* y = NULL;
	TreeElem* Node = root;
	//поиск места
	while (Node != 0)
	{
		//будущий родитель
		y = Node;
		if (z->keyNumb > Node->keyNumb)
			Node = Node->left;
		else
			Node = Node->right;
	}
	//заполняем родителя
	z->parent = y;
	if (y == 0) //элемент первый (единственный)
		root = z;
	//чей ключ больше?
	else if (z->keyNumb > y->keyNumb)
		y->left = z;
	else
		y->right = z;
}
void Tree::Del(TreeElem* z)
{
	//удаление куста
	if (z != 0)
	{
		TreeElem* Node, * y;
		//не 2 ребенка
		if (z->left == 0 || z->right == 0)
			y = z;
		else
			y = Next(z);
		if (y->left != 0)
			Node = y->left;
		else
			Node = y->right;
		if (Node != 0)
			Node->parent = y->parent;
		//Удаляется корневой узел?
		if (y->parent == 0)
			root = Node;
		else if (y == y->parent->left)
			//слева от родителя?
			y->parent->left = Node;
		else
			//справа от родителя?
			y->parent->right = Node;
		if (y != z)
		{
			//Копирование данных узла
			z->keyNumb = y->keyNumb;

		}
		delete y;
	}
	else //удаление всего дерева
		while (root != 0)
			Del(root);
}

	void Tree::add(int keyNumb, List <Penalty> listOfFines, TreeElem * &elem)
	{
		if (elem == NULL)
		{
			elem = new TreeElem;
			elem->keyNumb = keyNumb;
			elem->listOfFines = listOfFines;
			elem->left = nullptr;
			elem->right = nullptr;
			elem->parent = nullptr;
			return;
		}
		if (keyNumb > elem->keyNumb)
		{
			add(keyNumb, listOfFines, elem->right);
		}
		else
		{
			add(keyNumb, listOfFines, elem->left);
		}
	}
